// scripts/backfill_guest_profiles_and_check.js
// Backfill GuestProfile for users and map BookingParticipant to staff/guest refs.
// Safe to run multiple times (idempotent upserts + guarded updates).

/*
  What it does:
  1) Ensure every User has a GuestProfile (personalEmail = User.email).
  2) For BookingParticipant rows that still rely on legacy `userId`
     and have neither staff refs nor guest ref set:
       - If there is a UserRole for (userId, booking.orgId), set staffUserId+staffOrgId.
       - Else, attach the user's GuestProfile as guestProfileId.
  3) Print integrity summary:
       - total examined
       - mapped to staff (count)
       - mapped to guest (count)
       - invalid rows (both null OR both set) — should be 0 thanks to the DB CHECK.
*/

const { PrismaClient } = require("@prisma/client");
require("dotenv").config();

const prisma = new PrismaClient();

async function ensureGuestProfiles() {
  // Create GuestProfile for every User missing one.
  // We use upsert by userId; personalEmail defaults to User.email; visibility PRIVATE, inviteable true.
  const users = await prisma.user.findMany({
    select: { id: true, email: true },
  });

  let created = 0;
  for (const u of users) {
    try {
      await prisma.guestProfile.upsert({
        where: { userId: u.id },
        create: {
          id: undefined, // let DB default/cuid if you use it later; here text PK is fine to be generated by Prisma
          userId: u.id,
          personalEmail: u.email,
          visibility: "PRIVATE",
          inviteable: true,
        },
        update: {},
      });
      created++;
    } catch (e) {
      // If unique(personalEmail) collision happens, fall back to a tagged version of the email.
      if (String(e.message || "").includes("unique")) {
        const [local, domain] = u.email.split("@");
        const alt = `${local}+guest-${u.id}@${domain}`;
        await prisma.guestProfile.upsert({
          where: { userId: u.id },
          create: {
            userId: u.id,
            personalEmail: alt,
            visibility: "PRIVATE",
            inviteable: true,
          },
          update: {},
        });
        created++;
      } else {
        console.error("GuestProfile upsert error for user", u.id, e);
      }
    }
  }
  return { created };
}

async function backfillParticipants(batchSize = 200) {
  let cursor = null;
  let totalExamined = 0;
  let mappedStaff = 0;
  let mappedGuest = 0;

  for (;;) {
    const whereLegacy = {
      // Only rows that still depend on legacy userId and have no new refs set yet
      NOT: [
        { staffUserId: { not: null }, staffOrgId: { not: null } },
        { guestProfileId: { not: null } },
      ],
      userId: { not: null },
    };

    const rows = await prisma.bookingParticipant.findMany({
      where: whereLegacy,
      take: batchSize,
      ...(cursor ? { skip: 1, cursor: { id: cursor } } : {}),
      orderBy: { id: "asc" },
      select: {
        id: true,
        userId: true,
        bookingId: true,
        booking: { select: { orgId: true } },
      },
    });

    if (rows.length === 0) break;

    for (const p of rows) {
      totalExamined++;

      // Try to map to staff membership (UserRole) for this booking's org
      const role = await prisma.userRole.findUnique({
        where: { userId_orgId: { userId: p.userId, orgId: p.booking.orgId } },
        select: { userId: true, orgId: true },
      });

      if (role) {
        await prisma.bookingParticipant.update({
          where: { id: p.id },
          data: {
            staffUserId: role.userId,
            staffOrgId: role.orgId,
            guestProfileId: null,
          },
        });
        mappedStaff++;
      } else {
        // Ensure GuestProfile exists (idempotent); then attach it
        const gp = await prisma.guestProfile.upsert({
          where: { userId: p.userId },
          update: {},
          create: {
            userId: p.userId,
            personalEmail:
              (
                await prisma.user.findUnique({
                  where: { id: p.userId },
                  select: { email: true },
                })
              )?.email || `unknown+${p.userId}@example.invalid`,
            visibility: "PRIVATE",
            inviteable: true,
          },
          select: { id: true },
        });

        await prisma.bookingParticipant.update({
          where: { id: p.id },
          data: {
            guestProfileId: gp.id,
            staffUserId: null,
            staffOrgId: null,
          },
        });
        mappedGuest++;
      }
    }

    cursor = rows[rows.length - 1].id;
  }

  return { totalExamined, mappedStaff, mappedGuest };
}

async function runConsistencyCheck() {
  // Counts per state
  const [staffOnly, guestOnly, bothSet, neitherSet, total] = await Promise.all([
    prisma.bookingParticipant.count({
      where: {
        staffUserId: { not: null },
        staffOrgId: { not: null },
        guestProfileId: null,
      },
    }),
    prisma.bookingParticipant.count({
      where: {
        guestProfileId: { not: null },
        OR: [{ staffUserId: null }, { staffOrgId: null }],
      },
    }),
    prisma.bookingParticipant.count({
      where: {
        staffUserId: { not: null },
        staffOrgId: { not: null },
        guestProfileId: { not: null },
      },
    }),
    prisma.bookingParticipant.count({
      where: {
        staffUserId: null,
        staffOrgId: null,
        guestProfileId: null,
      },
    }),
    prisma.bookingParticipant.count(),
  ]);

  return { staffOnly, guestOnly, bothSet, neitherSet, total };
}

async function main() {
  console.log("Starting backfill…");
  const gp = await ensureGuestProfiles();
  console.log(`GuestProfile upserts: ${gp.created}`);

  const map = await backfillParticipants();
  console.log(
    `BookingParticipant backfill → examined=${map.totalExamined}, staff=${map.mappedStaff}, guest=${map.mappedGuest}`
  );

  const check = await runConsistencyCheck();
  console.log("Consistency summary:", check);

  if (check.bothSet > 0 || check.neitherSet > 0) {
    console.warn(
      "WARNING: Found invalid rows (both or neither). DB CHECK should prevent new ones, but historical data may need manual review."
    );
  } else {
    console.log(
      "Integrity OK: exactly-one-of staff/guest enforced across participants."
    );
  }
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
