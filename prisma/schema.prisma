// prisma/schema.prisma
// Base: Orgs, Users, Roles (slots 1..10), Bookings, Modes & Access (additive-only)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

/* =========================
   Enums
   ========================= */
enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
}

enum AppearanceType {
  IN_PERSON
  ONLINE
  PHONE
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
  CANCELLED
}

/* =========================
   Tenancy & Users
   ========================= */
model Organization {
  id        String   @id @default(cuid())
  name      String   @db.VarChar(200)

  // Access control
  orgRoles   OrgRole[]
  userRoles  UserRole[]

  // Modes & access (additive)
  modes              OrganizationMode[]
  modePresets        OrganizationModePreset[]
  accessPresets      OrganizationAccessPreset[]

  // Domain
  bookings  Booking[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
}

model User {
  id               String   @id @default(cuid())
  email            String   @unique @db.VarChar(320)
  hashedPassword   String   @db.VarChar(255)

  displayName      String?  @db.VarChar(200)
  avatarUrl        String?  @db.Text
  bio              String?  @db.Text

  languages        String[] @default([])
  tags             String[] @default([])
  supportsOnline   Boolean  @default(false)
  supportsInPerson Boolean  @default(false)
  city             String?  @db.VarChar(200)
  countryCode      String?  @db.VarChar(2)
  timeZone         String?  @db.VarChar(64)

  userRoles        UserRole[]
  bookingParticipants BookingParticipant[]
  notes               BookingNote[]

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([displayName])
  @@index([countryCode])
}

/* =========================
   Access Control (Roles 1–10)
   ========================= */
model PermissionKey {
  id            String   @id @default(cuid())
  key           String   @unique @db.VarChar(120)
  description   String?  @db.Text
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  templateLinks RoleTemplatePermission[]
  orgLinks      OrgRolePermission[]
}

model RoleTemplate {
  id                 String   @id @default(cuid())
  slot               Int      @unique
  defaultLabel       String   @db.VarChar(100)
  isActiveByDefault  Boolean  @default(false)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  permissions        RoleTemplatePermission[]
}

model RoleTemplatePermission {
  roleTemplateId  String
  permissionKeyId String
  roleTemplate  RoleTemplate  @relation(fields: [roleTemplateId], references: [id], onDelete: Cascade)
  permissionKey PermissionKey @relation(fields: [permissionKeyId], references: [id], onDelete: Cascade)
  @@id([roleTemplateId, permissionKeyId])
}

model OrgRole {
  id        String   @id @default(cuid())
  orgId     String
  slot      Int
  label     String   @db.VarChar(100)
  isActive  Boolean  @default(false)

  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  permissions OrgRolePermission[]
  assignments UserRole[] @relation("OrgRoleAssignments")

  @@unique([orgId, slot])
  @@index([orgId])
}

model OrgRolePermission {
  orgRoleId       String
  permissionKeyId String
  allowed         Boolean @default(true)

  orgRole       OrgRole       @relation(fields: [orgRoleId], references: [id], onDelete: Cascade)
  permissionKey PermissionKey @relation(fields: [permissionKeyId], references: [id], onDelete: Cascade)

  @@id([orgRoleId, permissionKeyId])
}

model UserRole {
  userId     String
  orgId      String
  slot       Int
  assignedAt DateTime @default(now())
  orgManaged Boolean  @default(false)

  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  orgRole OrgRole @relation("OrgRoleAssignments", fields: [orgId, slot], references: [orgId, slot], onDelete: Cascade)

  @@id([userId, orgId])
  @@index([orgId, slot])
}

/* =========================
   Modes (per org) + Presets & Access (additive)
   ========================= */

/** OrganizationMode
 * Route writes: { orgId, slot, active, label, accessFieldLabel }
 * We expose `active` but map it to the existing DB column `isActive`.
 */
model OrganizationMode {
  id        String   @id @default(cuid())
  orgId     String
  slot      Int
  label     String   @db.VarChar(120)
  active    Boolean  @map("isActive") @default(false)   // maps to existing column
  accessFieldLabel String?

  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  // *** Back-relations required by Prisma (additive, no DB changes) ***
  presets        OrganizationModePreset[]
  accessPresets  OrganizationAccessPreset[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([orgId, slot])
  @@index([orgId])
}

/** Catalog of access fields toggled per mode */
model OrganizationAccessField {
  id          String   @id @default(cuid())
  key         String   @unique @db.VarChar(120)
  label       String   @db.VarChar(200)
  description String?  @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Two different relations from AccessPreset -> AccessField need names
  presetsByAccessId  OrganizationAccessPreset[] @relation("AccessPresetByAccessFieldId")
  presetsByLegacyId  OrganizationAccessPreset[] @relation("AccessPresetByLegacyFieldId")
}

/** Mode presets (per OrganizationMode).
 * Route sends arrays like: [{ orgModeId, value }]
 * Legacy orgId/slot/label/active kept OPTIONAL (no drops).
 */
model OrganizationModePreset {
  id         String   @id @default(cuid())
  orgModeId  String
  value      String

  // legacy/optional (kept for compatibility)
  orgId      String?
  slot       Int?
  label      String?
  active     Boolean? @default(false)

  organizationMode OrganizationMode @relation(fields: [orgModeId], references: [id], onDelete: Cascade)
  organization     Organization?    @relation(fields: [orgId], references: [id], onDelete: SetNull)

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([orgModeId])
  @@index([orgId])
  @@unique([orgId, slot]) // legacy uniqueness (null-friendly)
}

/** Access presets (per OrganizationMode + AccessField).
 * Route sends arrays like: [{ orgModeId, accessFieldId, value }]
 * Legacy orgId/modeSlot/fieldId/allowed kept OPTIONAL (no drops).
 */
model OrganizationAccessPreset {
  id            String   @id @default(cuid())
  orgModeId     String
  accessFieldId String
  value         String?

  // legacy/optional (kept for compatibility)
  orgId     String?
  modeSlot  Int?
  fieldId   String?
  allowed   Boolean? @default(true)

  organizationMode OrganizationMode       @relation(fields: [orgModeId], references: [id], onDelete: Cascade)

  // *** disambiguated relations ***
  accessField     OrganizationAccessField @relation("AccessPresetByAccessFieldId", fields: [accessFieldId], references: [id], onDelete: Cascade)
  field           OrganizationAccessField?@relation("AccessPresetByLegacyFieldId", fields: [fieldId], references: [id], onDelete: SetNull)

  organization    Organization?           @relation(fields: [orgId], references: [id], onDelete: SetNull)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([orgModeId])
  @@index([accessFieldId])
  @@index([orgId])
  @@unique([orgId, modeSlot, fieldId]) // legacy uniqueness (null-friendly)
}

/* =========================
   Bookings & Participation
   ========================= */
model Booking {
  id            String   @id @default(cuid())
  orgId         String
  organization  Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  subject       String   @db.VarChar(300)
  status        BookingStatus @default(PENDING)
  startAt       DateTime
  durationMins  Int

  appearanceType  AppearanceType?
  locationUrl     String?
  locationName    String? @db.VarChar(300)
  locationAddress String?
  dialInfo        String?

  participants  BookingParticipant[]
  notes         BookingNote[]

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([orgId])
  @@index([startAt])
}

model BookingParticipant {
  id         String   @id @default(cuid())
  bookingId  String
  booking    Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  userId     String?
  user       User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  roleSlot   Int
  roleLabelSnapshot String? @db.VarChar(100)

  inviteStatus  InviteStatus @default(PENDING)

  invitedByUserId String?
  invitedAt       DateTime?
  respondedAt     DateTime?

  notes       String? @db.Text

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([bookingId, userId])
  @@index([bookingId])
  @@index([roleSlot])
  @@index([userId, inviteStatus])
}

model BookingNote {
  id        String   @id @default(cuid())
  bookingId String
  booking   Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  authorId  String
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)

  body      String   @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([bookingId, createdAt])
}

model GuestProfile {
  id            String   @id @default(cuid())
  personalEmail String   @unique
  passwordHash  String?  @db.VarChar(255) // ← NEW: hashed password for guest sign-in
  displayName   String?  // optional; future-friendly
  avatarUrl     String?  // optional
  inviteable    Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

