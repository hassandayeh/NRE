// prisma/schema.prisma
// Tenancy foundation + Org settings + Expert exclusivity + Booking.expert FK (non-breaking)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // Reads from DATABASE_URL in .env
  url      = env("DATABASE_URL")
}

/** ===== Enums ===== **/

/// Booking appearance mode
enum AppearanceType {
  IN_PERSON
  ONLINE
}

/// Booking workflow status (kept minimal)
enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
}

/// Organization/user roles for tenancy & permissions
enum Role {
  OWNER
  ADMIN
  PRODUCER
  EXPERT
}

/// Expert public visibility & exclusivity
enum ExpertStatus {
  PUBLIC
  EXCLUSIVE
}

/** ===== Core Tenancy Models ===== **/

/// Organizations (newsrooms or companies)
model Organization {
  id               String      @id @default(cuid())
  name             String      @db.VarChar(200)
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt

  // Settings (one row per org)
  settings         OrgSettings?

  // Tenancy relations
  memberships      OrganizationMembership[]

  // Reverse side of User.activeOrg (legacy/optional UI context)
  activeUsers      User[]      @relation("ActiveOrg")

  // Experts exclusively attached to this org (when exclusive)
  exclusiveExperts User[]      @relation("ExclusiveOrg")

  // Bookings scoped to an org
  bookings         Booking[]
}

/// DB-backed org settings (shell). Controls visibility/behaviour in UI.
model OrgSettings {
  id                String        @id @default(cuid())
  orgId             String        @unique
  organization      Organization  @relation(fields: [orgId], references: [id], onDelete: Cascade)

  // Field visibility toggles (MVP)
  showProgramName   Boolean       @default(true)
  showHostName      Boolean       @default(true)
  showTalkingPoints Boolean       @default(true)

  // Appearance type allowlist (MVP)
  allowInPerson     Boolean       @default(true)
  allowOnline       Boolean       @default(true)

  // Audit
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
}

/// User ↔ Organization membership with role
model OrganizationMembership {
  id           String   @id @default(cuid())
  userId       String
  orgId        String
  role         Role
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([userId, orgId])
  @@index([orgId])
  @@index([userId])
}

/** ===== App Models ===== **/

/// Application user
model User {
  id               String                @id @default(cuid())
  email            String                @unique @db.VarChar(320)
  name             String?               @db.VarChar(200)

  // Store a secure hash (bcrypt/argon2) — NOT plaintext
  hashedPassword   String                @db.VarChar(255)

  // ---- Legacy UI scoping (now deprecated in product; kept to avoid breaking code) ----
  activeOrgId      String?
  activeOrg        Organization?         @relation("ActiveOrg", fields: [activeOrgId], references: [id], onDelete: SetNull)
  @@index([activeOrgId])

  // Tenancy memberships (kept for Owner/Producer; product now disallows multi-org, to be enforced in app)
  memberships      OrganizationMembership[]

  // ---- Expert visibility/exclusivity (new) ----
  expertStatus     ExpertStatus?         @default(PUBLIC)
  exclusiveOrgId   String?
  exclusiveOrg     Organization?         @relation("ExclusiveOrg", fields: [exclusiveOrgId], references: [id], onDelete: SetNull)

  // Back-reference for bookings targeting this expert (needed by Prisma)
  bookingsAsExpert Booking[]             @relation("ExpertBookings")

  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
}

/// Bookings table (current UI fields; org-scoped)
model Booking {
  id             String         @id @default(cuid())
  subject        String         @db.VarChar(300)

  // NOTE: legacy expert string kept temporarily; will be removed after FK adoption
  expertName     String         @db.VarChar(200)

  newsroomName   String         @db.VarChar(200)
  appearanceType AppearanceType
  status         BookingStatus  @default(PENDING)
  startAt        DateTime
  durationMins   Int

  // Optional location fields
  locationName   String?        @db.VarChar(300)
  locationUrl    String?        @db.Text

  // Optional editorial extras (visibility controlled by OrgSettings)
  programName    String?        @db.VarChar(200)
  hostName       String?        @db.VarChar(200)
  talkingPoints  String?        @db.Text

  // Org scope
  orgId          String?
  organization   Organization?  @relation(fields: [orgId], references: [id], onDelete: SetNull)

  // ---- Expert FK (new; optional for now, to be backfilled) ----
  expertUserId   String?
  expert         User?          @relation("ExpertBookings", fields: [expertUserId], references: [id], onDelete: SetNull)

  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  @@index([orgId])
  @@index([startAt])
  @@index([expertUserId])
}
