// prisma/schema.prisma
// Tenancy foundation + Org settings + Expert exclusivity + Guests/Notes/Favorites
// + Appearance/Access scopes + Host FK + expertVisStatus (non-breaking for DB)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"           // Reads from DATABASE_URL in .env
  url      = env("DATABASE_URL")
}

/**
 * ===== Enums =====
 */

/// Booking appearance mode (used by Booking when UNIFIED and by each BookingGuest)
enum AppearanceType {
  IN_PERSON
  ONLINE
  PHONE
}

/// Booking workflow status (kept minimal)
enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
}

/// Organization/user roles for tenancy & permissions
enum Role {
  OWNER
  ADMIN
  PRODUCER
  EXPERT
  HOST
}

/// Expert public visibility & exclusivity
enum ExpertStatus {
  PUBLIC
  EXCLUSIVE
}

/// Appearance scope at the booking level
enum AppearanceScope {
  UNIFIED
  PER_GUEST
}

/// Access provisioning mode at the booking level
enum AccessProvisioning {
  SHARED
  PER_GUEST
}

/// Participant kind for guests on a booking
enum ParticipantKind {
  EXPERT
  REPORTER
}

/**
 * ===== Core Tenancy Models =====
 */

/// Organizations (newsrooms or companies)
model Organization {
  id               String                 @id @default(cuid())
  name             String                 @db.VarChar(200)
  createdAt        DateTime               @default(now())
  updatedAt        DateTime               @updatedAt

  // Settings (one row per org)
  settings         OrgSettings?

  // Tenancy relations
  memberships      OrganizationMembership[]

  // Reverse side of User.activeOrg (legacy/optional UI context)
  activeUsers      User[]                 @relation("ActiveOrg")

  // Experts exclusively attached to this org (when exclusive)
  exclusiveExperts User[]                 @relation("ExclusiveOrg")

  // Bookings scoped to an org
  bookings         Booking[]

  // ⭐ Back-relation for favorites
  favoriteLists    FavoriteList[]
}

/// DB-backed org settings (shell). Controls visibility/behaviour in UI (MVP).
model OrgSettings {
  id                String   @id @default(cuid())
  orgId             String   @unique
  organization      Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  // Field visibility toggles (MVP)
  showProgramName   Boolean  @default(true)
  showHostName      Boolean  @default(true)
  showTalkingPoints Boolean  @default(true)

  // Appearance type allowlist (MVP)
  allowInPerson     Boolean  @default(true)
  allowOnline       Boolean  @default(true)
  // (Phone is allowed by product flags/env; keeping schema minimal here)

  // Audit
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

/// User ↔ Organization membership with role
model OrganizationMembership {
  id           String   @id @default(cuid())
  userId       String
  orgId        String
  role         Role
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([userId, orgId])
  @@index([orgId])
  @@index([userId])
}

/**
 * ===== App Models =====
 */

/// Application user model
model User {
  id                String   @id @default(cuid())
  email             String   @unique @db.VarChar(320)
  name              String?  @db.VarChar(200) // legacy display; some UI still reads this

  // Store a secure hash (bcrypt/argon2) — NOT plaintext
  hashedPassword    String   @db.VarChar(255)

  // ---- New: Profile fields (non-breaking, optional) ----
  displayName       String?  @db.VarChar(200)
  avatarUrl         String?  @db.Text
  bio               String?  @db.Text
  languages         String[] @default([])     // e.g. ["en", "ar"]; default avoids null checks
  timeZone          String?  @db.VarChar(64)  // e.g. "Africa/Cairo"

  // ---- Legacy UI scoping (deprecated in product; kept to avoid breaking code) ----
  activeOrgId       String?
  activeOrg         Organization? @relation("ActiveOrg", fields: [activeOrgId], references: [id], onDelete: SetNull)

  // Tenancy memberships (kept for Owner/Producer/Host etc.)
  memberships       OrganizationMembership[]

  // ---- Expert visibility/exclusivity ----
  // Renamed Prisma field to expertVisStatus; mapped to old DB column "expertStatus" to avoid data migration.
  expertVisStatus   ExpertStatus? @default(PUBLIC) @map("expertStatus")
  exclusiveOrgId    String?
  exclusiveOrg      Organization? @relation("ExclusiveOrg", fields: [exclusiveOrgId], references: [id], onDelete: SetNull)

  // Back-relation for bookings targeting this expert
  bookingsAsExpert  Booking[] @relation("ExpertBookings")

  // Back-relation for bookings where this user is the Host
  bookingsAsHost    Booking[] @relation("HostBookings")

  // Notes authored by this user
  notes             BookingNote[]

  // Favorites created by this user
  favoriteListsCreated FavoriteList[] @relation("FavoriteListCreatedBy")

  // ⭐ Back-relations
  bookingGuests     BookingGuest[]
  favoritedIn       FavoriteListItem[]

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([activeOrgId])
}

/// Bookings table (current UI fields; org-scoped)
model Booking {
  id                 String       @id @default(cuid())
  subject            String       @db.VarChar(300)

  // ---- Legacy editorial fields (kept) ----
  expertName         String       @db.VarChar(200)
  newsroomName       String       @db.VarChar(200)
  talkingPoints      String?      @db.Text   // ✅ restored (optional)

  // ---- Appearance & Access (revised) ----
  appearanceScope    AppearanceScope   @default(UNIFIED)
  appearanceType     AppearanceType?   // used when UNIFIED; nullable when PER_GUEST
  accessProvisioning AccessProvisioning @default(SHARED)

  status             BookingStatus @default(PENDING)
  startAt            DateTime
  durationMins       Int

  // Booking defaults (used when UNIFIED and/or SHARED, and as fallbacks)
  // ONLINE
  locationUrl        String?      @db.Text
  // IN_PERSON
  locationName       String?      @db.VarChar(300)
  locationAddress    String?
  // PHONE
  dialInfo           String?

  // Optional editorial extras (visibility controlled by OrgSettings)
  programName        String?      @db.VarChar(200)
  hostName           String?      @db.VarChar(200)

  // Org scope
  orgId              String?
  organization       Organization? @relation(fields: [orgId], references: [id], onDelete: SetNull)

  // ---- Expert FK (legacy mirror; optional; to be deprecated later) ----
  expertUserId       String?
  expert             User?        @relation("ExpertBookings", fields: [expertUserId], references: [id], onDelete: SetNull)

  // ---- Host FK (new; first-class Host selection) ----
  hostUserId         String?
  host               User?        @relation("HostBookings", fields: [hostUserId], references: [id], onDelete: SetNull)

  // Guests & notes
  guests             BookingGuest[]
  notes              BookingNote[]

  createdAt          DateTime     @default(now())
  updatedAt          DateTime     @updatedAt

  @@index([orgId])
  @@index([startAt])
  @@index([expertUserId])
  @@index([hostUserId])
}

/// Join table for booking participants (experts/reporters) with per-guest appearance & access
model BookingGuest {
  id            String    @id @default(cuid())

  bookingId     String
  booking       Booking   @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  // Internal or external
  userId        String?   // nullable for external guest snapshots
  user          User?     @relation(fields: [userId], references: [id], onDelete: SetNull)

  // External snapshot
  name          String    // snapshot for external guests; for internal, duplicate of user.name at time of add
  kind          ParticipantKind // EXPERT | REPORTER

  // Display order
  order         Int       @default(0)

  // Per-guest appearance & access
  appearanceType AppearanceType
  // ONLINE
  joinUrl       String?
  // IN_PERSON
  venueName     String?
  venueAddress  String?
  // PHONE
  dialInfo      String?

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Prevent the same internal user from being added twice to the same booking
  @@unique([bookingId, userId])
  @@index([bookingId, order])
  @@index([bookingId, kind])
}

/// Notes attached to a booking (auth: HOST+ can create; readable by HOST+)
model BookingNote {
  id         String   @id @default(cuid())
  bookingId  String
  booking    Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  authorId   String
  author     User     @relation(fields: [authorId], references: [id], onDelete: Cascade)

  body       String   @db.Text

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([bookingId, createdAt])
}

/**
 * ===== Favorites (org-wide lists) =====
 */
model FavoriteList {
  id          String        @id @default(cuid())
  orgId       String
  organization Organization  @relation(fields: [orgId], references: [id], onDelete: Cascade)

  name        String        @db.VarChar(200)

  createdById String
  createdBy   User          @relation("FavoriteListCreatedBy", fields: [createdById], references: [id], onDelete: Cascade)

  items       FavoriteListItem[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([orgId, name])
}

model FavoriteListItem {
  id            String       @id @default(cuid())
  listId        String
  list          FavoriteList @relation(fields: [listId], references: [id], onDelete: Cascade)

  // the favorited expert/reporter user
  targetUserId  String
  targetUser    User         @relation(fields: [targetUserId], references: [id], onDelete: Cascade)

  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  // Unique per list/target user
  @@unique([listId, targetUserId])
}
