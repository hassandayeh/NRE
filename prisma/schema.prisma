// prisma/schema.prisma
// === Clean Base Schema (slot-based roles) ===
// - Organizations, Users
// - Slot-based roles (1..10) with per-org labels
// - Bookings + participants
// - Modes (OrganizationMode) for /api/org/modes routes

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

/**
 * =========================
 * Enums
 * =========================
 */
enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
}

enum AppearanceType {
  IN_PERSON
  ONLINE
  PHONE
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
  CANCELLED
}

/**
 * =========================
 * Tenancy & Users
 * =========================
 */
model Organization {
  id        String   @id @default(cuid())
  name      String   @db.VarChar(200)

  // Access control
  orgRoles  OrgRole[]
  userRoles UserRole[]

  // Modes
  modes     OrganizationMode[]

  // Domain
  bookings  Booking[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
}

model User {
  id               String   @id @default(cuid())
  email            String   @unique @db.VarChar(320)
  hashedPassword   String   @db.VarChar(255)

  // Display/profile
  displayName      String?  @db.VarChar(200)
  avatarUrl        String?  @db.Text
  bio              String?  @db.Text

  // Directory/search facets
  languages        String[] @default([])
  tags             String[] @default([])
  supportsOnline   Boolean  @default(false)
  supportsInPerson Boolean  @default(false)
  city             String?  @db.VarChar(200)
  countryCode      String?  @db.VarChar(2)
  timeZone         String?  @db.VarChar(64)

  // Access
  userRoles        UserRole[]

  // Participation
  bookingParticipants BookingParticipant[]
  notes               BookingNote[]

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([displayName])
  @@index([countryCode])
}

/**
 * =========================
 * Access Control (Roles 1–10)
 * =========================
 */

// Canonical permission catalog
model PermissionKey {
  id            String   @id @default(cuid())
  key           String   @unique @db.VarChar(120)
  description   String?  @db.Text
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  templateLinks RoleTemplatePermission[]
  orgLinks      OrgRolePermission[]
}

// Default slots 1..10 with default labels and permissions
model RoleTemplate {
  id                 String   @id @default(cuid())
  slot               Int      @unique   // 1..10
  defaultLabel       String   @db.VarChar(100)
  isActiveByDefault  Boolean  @default(false)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  permissions        RoleTemplatePermission[]
}

model RoleTemplatePermission {
  roleTemplateId  String
  permissionKeyId String

  roleTemplate  RoleTemplate  @relation(fields: [roleTemplateId], references: [id], onDelete: Cascade)
  permissionKey PermissionKey @relation(fields: [permissionKeyId], references: [id], onDelete: Cascade)

  @@id([roleTemplateId, permissionKeyId])
}

// Per-org instance of a slot with label + active toggle
model OrgRole {
  id        String   @id @default(cuid())
  orgId     String
  slot      Int
  label     String   @db.VarChar(100)
  isActive  Boolean  @default(false)

  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  permissions OrgRolePermission[]
  assignments UserRole[] @relation("OrgRoleAssignments")

  @@unique([orgId, slot])
  @@index([orgId])
}

model OrgRolePermission {
  orgRoleId       String
  permissionKeyId String
  allowed         Boolean @default(true)

  orgRole       OrgRole       @relation(fields: [orgRoleId], references: [id], onDelete: Cascade)
  permissionKey PermissionKey @relation(fields: [permissionKeyId], references: [id], onDelete: Cascade)

  @@id([orgRoleId, permissionKeyId])
}

// Membership = role assignment (one per user per org)
model UserRole {
  userId     String
  orgId      String
  slot       Int
  assignedAt DateTime @default(now())

  // used by API/seed
  orgManaged Boolean  @default(false)

  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  // Composite relation to the org's chosen slot (enforces slot exists)
  orgRole OrgRole @relation("OrgRoleAssignments", fields: [orgId, slot], references: [orgId, slot], onDelete: Cascade)

  @@id([userId, orgId])        // exactly one role per user per org
  @@index([orgId, slot])
}

/**
 * =========================
 * Modes (per org)
 * =========================
 * Matches API at /api/org/modes/route.ts which upserts by (orgId, slot)
 */
model OrganizationMode {
  id        String   @id @default(cuid())
  orgId     String
  slot      Int
  label     String   @db.VarChar(120)
  isActive  Boolean  @default(false)

  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([orgId, slot]) // enables where: { orgId_slot: { orgId, slot } }
  @@index([orgId])
}

/**
 * =========================
 * Bookings & Participation
 * =========================
 */
model Booking {
  id            String   @id @default(cuid())
  orgId         String
  organization  Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  subject       String   @db.VarChar(300)
  status        BookingStatus @default(PENDING)
  startAt       DateTime
  durationMins  Int

  // Optional shared “where” defaults
  appearanceType  AppearanceType?
  locationUrl     String?
  locationName    String? @db.VarChar(300)
  locationAddress String?
  dialInfo        String?

  participants  BookingParticipant[]
  notes         BookingNote[]

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([orgId])
  @@index([startAt])
}

model BookingParticipant {
  id         String   @id @default(cuid())
  bookingId  String
  booking    Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  userId     String?
  user       User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  roleSlot   Int
  roleLabelSnapshot String? @db.VarChar(100)

  inviteStatus  InviteStatus @default(PENDING)

  invitedByUserId String?
  invitedAt       DateTime?
  respondedAt     DateTime?

  notes       String? @db.Text

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([bookingId, userId])
  @@index([bookingId])
  @@index([roleSlot])
  @@index([userId, inviteStatus])
}

model BookingNote {
  id        String   @id @default(cuid())
  bookingId String
  booking   Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  authorId  String
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)

  body      String   @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([bookingId, createdAt])
}
