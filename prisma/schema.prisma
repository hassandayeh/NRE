// prisma/schema.prisma
// Tenancy foundation + Org settings + Expert exclusivity + Guests/Notes/Favorites
// + Appearance/Access scopes + Host FK + expertVisStatus (non-breaking) + Search fields

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  // Reads from DATABASE_URL in .env
  url      = env("DATABASE_URL")
}

/**
 * ===== Enums =====
 */

/// Booking appearance mode (used by Booking when UNIFIED and by each BookingGuest)
enum AppearanceType {
  IN_PERSON
  ONLINE
  PHONE
}

/// Booking workflow status (kept minimal)
enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
}

/// Organization/user roles for tenancy & permissions
enum Role {
  OWNER
  ADMIN
  PRODUCER
  EXPERT
  HOST
  REPORTER // ← ADDED
}

/// Expert public visibility & exclusivity
enum ExpertStatus {
  PUBLIC
  EXCLUSIVE
}

/// Appearance scope at the booking level
enum AppearanceScope {
  UNIFIED
  PER_GUEST
}

/// Access provisioning mode at the booking level
enum AccessProvisioning {
  SHARED
  PER_GUEST
}

/// Participant kind for guests on a booking
enum ParticipantKind {
  EXPERT
  REPORTER
}

/**
 * ===== Core Tenancy Models =====
 */

/// Organizations (newsrooms or companies)
model Organization {
  id        String   @id @default(cuid())
  name      String   @db.VarChar(200)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Settings (one row per org)
  settings OrgSettings?

  // Tenancy relations
  memberships OrganizationMembership[]

  // Reverse side of User.activeOrg (legacy/optional UI context)
  activeUsers User[] @relation("ActiveOrg")

  // Experts exclusively attached to this org (when exclusive)
  exclusiveExperts User[] @relation("ExclusiveOrg")

  // Bookings scoped to an org
  bookings Booking[]

  // ⭐ Back-relation for favorites
  favoriteLists FavoriteList[]
}

/// DB-backed org settings (shell). Controls visibility/behaviour in UI (MVP).
model OrgSettings {
  id        String   @id @default(cuid())
  orgId     String   @unique
  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  // Field visibility toggles (MVP)
  showProgramName  Boolean @default(true)
  showHostName     Boolean @default(true)
  showTalkingPoints Boolean @default(true)

  // Appearance type allowlist (MVP)
  allowInPerson Boolean @default(true)
  allowOnline   Boolean @default(true)

  // Audit
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

/// User ↔ Organization membership with role
model OrganizationMembership {
  id        String   @id @default(cuid())
  userId    String
  orgId     String
  role      Role
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([userId, orgId])
  @@index([orgId])
  @@index([userId])
}

/**
 * ===== App Models =====
 */

/// Application user model
model User {
  id             String   @id @default(cuid())
  email          String   @unique @db.VarChar(320)
  name           String?  @db.VarChar(200) // legacy display; some UI still reads this
  // Store a secure hash (bcrypt/argon2) — NOT plaintext
  hashedPassword String   @db.VarChar(255)

  // ---- Profile fields (optional) ----
  displayName    String?  @db.VarChar(200)
  avatarUrl      String?  @db.Text
  bio            String?  @db.Text

  // Searchable expert metadata
  languages      String[] @default([]) // e.g. ["en","ar"]; default avoids null checks
  tags           String[] @default([]) // e.g. ["technology","ai"]
  supportsOnline Boolean  @default(false)
  supportsInPerson Boolean @default(false)
  city           String?  @db.VarChar(200)
  countryCode    String?  @db.VarChar(2)   // ISO-3166-1 alpha-2
  timeZone       String?  @db.VarChar(64)  // e.g. "Africa/Cairo"

  // ---- Legacy UI scoping (kept to avoid breaking code) ----
  activeOrgId String?
  activeOrg   Organization? @relation("ActiveOrg", fields: [activeOrgId], references: [id], onDelete: SetNull)

  // Tenancy memberships (kept for Owner/Producer/Host/Reporter/etc.)
  memberships OrganizationMembership[]

  // ---- Expert visibility/exclusivity ----
  // Prisma field mapped to legacy DB column "expertStatus" to avoid data migration
  expertVisStatus ExpertStatus? @default(PUBLIC) @map("expertStatus")
  exclusiveOrgId  String?
  exclusiveOrg    Organization? @relation("ExclusiveOrg", fields: [exclusiveOrgId], references: [id], onDelete: SetNull)

  // Back-relations
  bookingsAsExpert Booking[] @relation("ExpertBookings")
  bookingsAsHost   Booking[] @relation("HostBookings")
  notes            BookingNote[]
  favoriteListsCreated FavoriteList[] @relation("FavoriteListCreatedBy")
  bookingGuests     BookingGuest[]
  favoritedIn       FavoriteListItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([activeOrgId])
  @@index([name])
  @@index([countryCode])
  @@index([displayName])
}

/// Bookings table (current UI fields; org-scoped)
model Booking {
  id        String   @id @default(cuid())
  subject   String   @db.VarChar(300)

  // ---- Legacy editorial fields (kept) ----
  expertName   String   @db.VarChar(200)
  newsroomName String   @db.VarChar(200)
  talkingPoints String? @db.Text // optional

  // ---- Appearance & Access (revised) ----
  appearanceScope AppearanceScope @default(UNIFIED)
  appearanceType  AppearanceType? // used when UNIFIED; nullable when PER_GUEST
  accessProvisioning AccessProvisioning @default(SHARED)
  status BookingStatus @default(PENDING)

  startAt      DateTime
  durationMins Int

  // Booking defaults (used when UNIFIED and/or SHARED, and as fallbacks)
  // ONLINE
  locationUrl   String?  @db.Text
  // IN_PERSON
  locationName    String? @db.VarChar(300)
  locationAddress String?
  // PHONE
  dialInfo      String?

  // Optional editorial extras (visibility controlled by OrgSettings)
  programName String? @db.VarChar(200)
  hostName    String? @db.VarChar(200)

  // Org scope
  orgId        String?
  organization Organization? @relation(fields: [orgId], references: [id], onDelete: SetNull)

  // ---- Expert FK (legacy mirror; optional; to be deprecated later) ----
  expertUserId String?
  expert       User? @relation("ExpertBookings", fields: [expertUserId], references: [id], onDelete: SetNull)

  // ---- Host FK (first-class Host selection) ----
  hostUserId String?
  host       User? @relation("HostBookings", fields: [hostUserId], references: [id], onDelete: SetNull)

  // Guests & notes
  guests BookingGuest[]
  notes  BookingNote[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orgId])
  @@index([startAt])
  @@index([expertUserId])
  @@index([hostUserId])
}

/// Join table for booking participants with per-guest appearance & access
model BookingGuest {
  id        String   @id @default(cuid())
  bookingId String
  booking   Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  // Internal or external
  userId String?   // nullable for external guest snapshots
  user   User?     @relation(fields: [userId], references: [id], onDelete: SetNull)

  // External snapshot
  name String // snapshot for external guests; for internal, duplicate of user.name at time of add
  kind ParticipantKind // EXPERT | REPORTER

  // Display order
  order Int @default(0)

  // Per-guest appearance & access
  appearanceType AppearanceType
  // ONLINE
  joinUrl String?
  // IN_PERSON
  venueName    String?
  venueAddress String?
  // PHONE
  dialInfo String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Prevent the same internal user from being added twice to the same booking
  @@unique([bookingId, userId])
  @@index([bookingId, order])
  @@index([bookingId, kind])
}

/// Notes attached to a booking (auth: HOST+ can create; readable by HOST+)
model BookingNote {
  id        String   @id @default(cuid())
  bookingId String
  booking   Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  authorId String
  author   User @relation(fields: [authorId], references: [id], onDelete: Cascade)

  body String @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([bookingId, createdAt])
}

/**
 * ===== Favorites (org-wide lists) =====
 */

model FavoriteList {
  id      String   @id @default(cuid())
  orgId   String
  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  name   String @db.VarChar(200)

  createdById String
  createdBy   User @relation("FavoriteListCreatedBy", fields: [createdById], references: [id], onDelete: Cascade)

  items FavoriteListItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orgId, name])
}

model FavoriteListItem {
  id      String   @id @default(cuid())
  listId  String
  list    FavoriteList @relation(fields: [listId], references: [id], onDelete: Cascade)

  // the favorited expert/reporter user
  targetUserId String
  targetUser   User @relation(fields: [targetUserId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Unique per list/target user
  @@unique([listId, targetUserId])
}
